# Hibernate锁机制
## 一、简介
为了防止并发操作时出现冲突，导致损坏数据完整性，出现脏读、丢失更新的情况，Hibernate 支持 2 种锁机制，乐观锁与悲观锁。与 Elasticsearch 中悲观并发控制(**PCC**)
和乐观并发控制(OCC)一样。

## 二、悲观锁 VS. 乐观锁
| **特征** | **乐观锁** | **悲观锁** |
| :--- | :--- | :--- |
| **概念** | **假设不会/不经常**发生并发冲突，**只在提交事务操作时检验数据完整性** | **假设一定/经常会**发生并发冲突，对数据被外界修改持保守状态，**屏蔽一切**可能违反数据完整性的操作 |
| **机制** | 一般基于数据库**版本记录(version)机制** | 一般基于数据库的**锁机制** |
| **优劣** | 高性能，低数据完整性 | 低性能，数据完整性强 |
| **案例** | 用**自增长的整数表示数据版本号，更新时检查版本号是否一致**。如数据库中版本为6，更新提交时version=6+1=7, 用该version值与数据库version+1作比较。若相等，则更新；若不等，则有可能其他程序已更新该记录，返回错误 | **读取**一行**数据前先锁定**这一行，然后确保只有读取到数据的这个线程可以修改这一行数据 |
| **生产环境** | **并发量高时**使用，提高性能 | **并发低且不许脏读**时使用，强数据完整性 |

### 2.1 乐观锁 `@version`
Hibernate通过注解`@version`来自动完成检查 version、修改数据、更新 version 值等工作。
```
@Entity
@Table(name="user")
public class User{
    @Id
    @GeneratedValue
    private int id;

    @Column(name="name", length = 100)
    private String name;

    @Version
    private int version;

    public User(){}

    //getter...
    //setter...

}
```
> Note: version 节点**必须**出现在 ID 节点之后