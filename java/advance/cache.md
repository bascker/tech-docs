# 缓存
## 一、简介
几种缓存问题
* 缓存穿透

## 二、缓存穿透
查询一个**一定不存在**的数据，这样缓存无法命中就会去DB进行查询。从OS层面就像是穿透了缓存层直达DB，从而称为缓存穿透。

没有缓存的保护，这种查询一定不存在的数据对OS可能是中危险，若恶意不断发送这种请求攻击系统，所有请求都达到DB，导致数据库瘫痪，从而引起系统故障。

常用解决方案
* bloom filter：类似哈希表的算法，使用所有可能的查询条件生成一个bitmap，进行DB查询前使用该 bitmap 进行过滤，若不存在，则过滤，从而减轻DB的压力（Java 中 Guava 库中有实现BloomFilter算法）
* 空值缓存：第一次查询完不存在的数据后，将该 key 和空值放入cache中，并设置较短的TTL时间，从而应对短时间的大量该 key 攻击。

## 三、缓存雪崩
对于redis、memcache等缓存系统，若所有预设置的 TTL 相同，当 TTL 同时失效时，所有的请求将全部进入DB层，从而可能导致系统崩溃，这种场景就叫缓存雪崩。

常用解决方案
* 线程互斥：只让一个线程构建缓存（称为cacheThread），其他线程等待 cacheThread 执行完毕后，再从 cache 中获取数据，每个时刻只有一个线程执行请求，从而减轻DB压力。缺点就是降低了系统 qps
* 交错失效时间：即设置不同的TTL，错开失效时间。在进行 TTL 设置时，随机从某个值域中挑选一个时间作为 TTL。

## 四、缓存击穿
缓存雪崩的一个特例，系统会对于热点数据设置TTL，当热点数据缓存TTL达到时，大量请求可能就穿透缓存层的保护，进入DB，引起故障。

缓存雪崩 VS. 缓存击穿：前者是全部数据，后者是热点数据。

常用解决方案
* 二级缓存：对于热点数据进行二级缓存，并对不同级别的缓存设置不同TTL。
* LRU：最近最少使用算法，根据数据历史访问记录来淘汰数据，常用是使用链表来保存缓存数据
